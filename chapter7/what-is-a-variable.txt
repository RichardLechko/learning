7.2 What Is a Variabe?

this discusses what attributes a variable possesses.

7.2.1 Attributes

attributes in a variable:

1. name
2. memory address
3. size (in bytes)
4. runtime value
5. data type

not all variables share these attributes, like a constant doesn't have a memory location and it might not have a name

7.2.2 Binding

Binding "is the process of associating an attribute with an object."

when you do int a = 1, the value 1 is bound to that variable.

similarly, if you allocate memory for a variable, the variable is bound to that memory address.

7.2.3 Static Objects

static "objects have an attribute bound to them prior to the application's execution."
constants are an example of this.

7.2.4 Dynamic Objects

these are the opposite of static objects. a dynamic object has some attribute bound to them during the program execution.
dynamic objects usually cant be determined at compile time.

7.2.5 Scope

the scope is the section of the program where the identifiers name is bound to the object.
since names are created usually during compile time, scope is thus usually a static attribute.
this allows you to reuse the name of a variable throughout the file. this is how we have local and global variables.

a "local variable's name is bound to a particular object only within a given section of a program ...
outside the scope of that object, the name can be bound to a different object."
hence why we can have a global and local variable to have the same name.

in interpreted languages, the scope can be a dynamic attribute,

7.2.6 Lifetime

this just determines how long a variable can stay alive. so when the memory gets deallocated.

since static objects are binded at compile time (before execution) the static object's lifetime is when the program terminates.
"the lifetime of a variable is from the time you first allocte memory ... to the moment you dellocate that variable's storage."

7.2.7 Variable Definition

"we can now define variable as an object that can have a value bound to it dynamically ... the program can change the ... value attribute at runtime."
"only the binding of the value determines whether the object is a variable or something else"

7.3 Variable storage
variables require to be stored in and retrieved from memory.
the type of variable determines the size.
a compiler will bind a memory address to a variable.
if there are 2 or more memory locations, the system binds the first location then just assumes the other memory locations are bound at runtime.
three types of binding are possible between variables and memory locations:
1. static binding
2. psuedo-static (automatic) binding
3. dynamic binding
this is how a variable is determined to be dynamic, static, or automatic, based on how they are bound to a memory address.

7.3.1 Static Binding and Static Variables

the static values get a value bounded to them prior to runtime at 4 possible spots:
1. language design time
2. at compile time
3. link time
4. when the OS loads the app into memory - the OS copies the .exe into memory

7.3.1.1 Binding at Language Design time

the language designer assigns a address at language design time if the language designer feels that the language defined variable -
requires a specific hardware address. "an I/O device or a special kind of memory"

7.3.1.2 Binding at Compile time

the compiler can assign an address to a variable at compile time when the compiler knows the memory region where it can place the static -
variables at runtime.

7.3.1.3 Binding at Link time

you can use linkers to bind memory addresses to the variables, and "the programmer specifies ... the base address of all the static
variables ... [and] the linker will bind the static variables to consecutive addresses".

kind of like making your own unique %rbp?

7.3.1.4 Binding at Load Time

this is the most common

windows and linux usually "embed relocation information" in the .exe file.

the OS loads the app into memory, then decides where to place all the static variables.

7.3.1.5 Static Variable Binding

static variable gets bounded prior to runtime.

advantages:

1. the compiler can use an "absolute addressing mode" to access that variable.
2. compilers can access static variables easier since there's no additional startup
3. static fields retain the value until explicitly changed or the program terminates
4. different threads in a multithreaded application can share the same static variable.

disadvantages:

1. since the lifetime of a static field is prior to runtime all the way till the program terminates,
it will consume memory the entire time.
2. if the compiler utilizies "absolute addressing mode", then the entire address gets encoded and makes the instruction massive.
3. even if different threads can share the same static variable, they cant be used concurrently. code that uses static objects
is not "reentrant" which means its not possible for more than one thread to execute the same code concurrently.

7.3.2 Psuedo-Static Binding and Automatic Variables