7.4 Common Primative Data Types

two types of data types: primative & composite data types.

primative data types can be directly baked into machine instruction.

composite data types are made up of smaller primative data types

7.4.1. Integer Variables

some languages let you decide how big you want to make an int variable. some dont.

C has char, short, int, long, and long long. technically all could be the same size.

the type of integer you choose tells the CPU how much memory to allocate.

here are some common sizes for integers:

8 bits:
Unsigned -> 0 - 255
Signed -> -128 - 127
Decimal -> 0..99

16 bits:
Unsigned -> 0 - 65,536
Signed -> -32,768 - 32,767
Decimal -> 0..9999

32 bits:
Unsigned -> 0 - 4,294,967,295
Signed -> -2,147,483,648 - 2,147,483,647
Decimal -> 0..99999999

64 bits:
Unsigned -> 0 - 18,466,744,073,709,551,615
Signed -> -9,223,372,036,854,775,808 - 9,223,372,036,854,775,807
Decimal -> 0..9999999999999999

128 bits:
Unsigned -> 0 - 340,282,366,920,938,463,563,374,607,431,768,211,455
Signed -> -170,141,183,460,469,231,731,687,303,715,884,105,728 - 170,141,183,460,469,231,731,687,303,715,884,105,727
Decimal -> 0..99999999999999999999999999999999

the reason why the ambiguity of the sizes of ints is intentional is because its best for the compiler to determine the "best size" for the int.

on certain CPU's, "unsigned integer multiplication and division are faster than their signed counterparts"

some languages let you add big nums with small nums (of different types) and the "compiler automatically sign-extends or zero-extends operands
to the larger size" but this can be problematic since extra work is being done.

using an integer size larger than the CPU's general purpose integer register is inefficient (obvious)

"Even on the CISC processors, such as the 80x86, that have hardware support for different sizes of integers, using certain sizes
can be more expensive ...[;] under 32-bit [OS] instructions that manipulate 16-bit operands require an extra *opcode prefix byte* and are therefore
larger than instructions that operate on 8-bit or 32-bit operands." Check if this is true..?

7.4.2 Floating-Point / Real Variables

"differnt floating-point formats trade off space and performance for precision. Calculations involving smaller floating-point formats are usually quicker" than bigger floats.
dont mix diff sizes of floats
conversion between int and floats is expensive and should be avoided.

7.4.3 Character Variables

on 80x86, a character data is 1 byte and thankfully 80x86 "can reserve a single byte of storage for each character variable" while some processors
can only access in chunks of 32 bits.

"Unicode characters can require between 1 and 4 bytes of memory"

7.4.4 Boolean Variables

a boolean variable is just 1 bit: true or false