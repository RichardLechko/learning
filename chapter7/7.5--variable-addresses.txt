7.5 Variable Addresses and High-Level Languages

"This section describes how you can organize your variable declarations to produce efficient code."

many CPUs have whats called "addressing modes" that allow the CPU to use different types of addressing. like how a immediate constant gets accessed in memory
more efficient than others

constants -> worry about the value
variables -> must consider the address in memory where the compiler places them

"the 80x86 CPU supports three address sizes: 0 bit, 8 bit, and 32 bit. The 80x86 uses 0-bit displacements for register-indirect addressing modes."

7.5.1 Allocating Storage for Global and Static Variables

if you declare a variable and its not slotted in a register it is then instead placed in memory

on 32 bit OS, it takes 32 bit address to access a variable at an arbitrary location in memory. if you encode this 32 bit address, you can access anything in memory.

"The 80x86 provides the displacement-only addressing mode, whose effective address is exactly the 32-bit constant embedded in the instruction."

in a 32/64 bit OS, the 32/64 bit address takes up most of the instructions encoding. so if you are doing operation with a 1 byte opcode, and you have -
a 4 byte address, 80% of the operation is just the address. if it was 64 bit OS, that would be 9 bytes which is ~90%. 80x86 no longer encodes the absolute 32/64 bit -
address in memory then into the instruction, it instead encodes a signed 32-bit offset (+/- 2B bytes).

7.5.2 Using Automatic Variables to Reduce Offset Sizes

80x86 allows for a 8 bit displacement form for the base-plus-indexes addressing mode, which allows access to an offset of -128 - 127 bytes.

a really optimal solution is to have a register point to a base address in memory and placing your variables near that base address.

whenever you have code like this:

function trivial( int i, int j) { ... }

this function call code "constructs an activation record (sometimes called a stack frame). An activation record ... is a data structure in memory -
where the system keeps the local data associated with a function or procedure."

this activation record holds the parameter data, automatic variables, the return address, temp variables that the compiler allocates, and machine state information.

the runtime system allocates all the storage for this activation record

in high level languages point a register called the frame pointer at the activation record and then when automatic variables or parameters are referenced -
they are allocated "at some offset from the frame pointer." We see this when we do int argc and we see -4 bytes from %rbp. these variables and parameters -
unless they are large, will appear in memory at an offset near the base address.

"If your compiler allocates local variables and parameters in an activation record, all you have to do is arrange your variables in the activation record
so that they appear near its base address."

whenever a function is called, the activation record gets constructed. the parameters parameters get pushed on the stack in order they appear - left to right.
once the parameters are pushed on the stack, the program calls the function.

the stack pointer initially ponits to the return address (check if this is true)

if you have this function -> function demo(int i, int j, string k) the stack would look like this:

Previous Stack Contents
i value
j value
k value
Return Address (stack pointer)

once the function demo is called, the value in the frame pointer register (%rbp) gets pushed onto the stack and copied into the stack pointer (%rsp).
then the program drops the stack pointer down in memory to make room for the local variables.

so then if you have this function:

function demo(int i, int j, string k) {
    int a, b, c, d;
}

your stack would look like:

i value
j value
k value
Return Address (stack pointer)
Old EBP Value
a
b
c
d <- ESP

these are the byte representation of the stack:

i value +16 Byte
j value +12 Byte
k value +8 Byte
Return Address +4 Byte
Old EBP Value +0 Byte
a -4 Byte
b -8 Byte
c -12 Byte
d -16 Byte

the idea is that the stack pointer (rsp/rbp/ebp/esp) point to the base of the activation record and parameters are + offset and local variables are - offset.

looking at this stack, since all the local variables and parameters are within 127 bytes of the frame pointer register, a 80x86 CPU can produce an instruction -
to reference any of these fields will  be able to encode the offset using a single byte.

for this C/C++ function:

int BigLocals( int i, int j) {
    int array[256]
    int k;
}

this is our activation record on a 32 bit OS running 80x86:

Previous Stack Contents -> Offset from EBP
j's value -> +12 Bytes
i's value -> +8 Bytes
Return Address -> +4 Bytes
Old EBP Value -> +0 Bytes (EBP)
Array -> -1,024 Bytes
k -> -1,028 Bytes

In C, the parameters are pushed in reverse order, C pushes the last parameter first and the first parameter last.

since this array is outside of the -128 - +127 byte range, the compiler can no longer encode the displacements using 1 byte.
the compiler has to encode these displacements using a 32-bit value.

but then what if the acivation record was this:

Previous Stack Contents -> Offset from EBP
j's value -> +12 Bytes
i's value -> +8 Bytes
Return Address -> +4 Bytes
Old EBP Value -> +0 Bytes (EBP)
k -> -4 Bytes
Array -> -1,028 Bytes

well now while it still takes 32-bit displacement to access the array you can now access "k" still using 1 byte encoding. so the order does matter.

you should declare your variables like this:

1. 1 byte variables
2. 2 byte variables
3. 4 byte variables
4-n. and so on...