7.3 Variable storage
variables require to be stored in and retrieved from memory.
the type of variable determines the size.
a compiler will bind a memory address to a variable.
if there are 2 or more memory locations, the system binds the first location then just assumes the other memory locations are bound at runtime.
three types of binding are possible between variables and memory locations:
1. static binding
2. psuedo-static (automatic) binding
3. dynamic binding
this is how a variable is determined to be dynamic, static, or automatic, based on how they are bound to a memory address.

7.3.1 Static Binding and Static Variables

the static values get a value bounded to them prior to runtime at 4 possible spots:
1. language design time
2. at compile time
3. link time
4. when the OS loads the app into memory - the OS copies the .exe into memory

7.3.1.1 Binding at Language Design time

the language designer assigns a address at language design time if the language designer feels that the language defined variable -
requires a specific hardware address. "an I/O device or a special kind of memory"

7.3.1.2 Binding at Compile time

the compiler can assign an address to a variable at compile time when the compiler knows the memory region where it can place the static -
variables at runtime.

7.3.1.3 Binding at Link time

you can use linkers to bind memory addresses to the variables, and "the programmer specifies ... the base address of all the static
variables ... [and] the linker will bind the static variables to consecutive addresses".

kind of like making your own unique %rbp?

7.3.1.4 Binding at Load Time

this is the most common

windows and linux usually "embed relocation information" in the .exe file.

the OS loads the app into memory, then decides where to place all the static variables.

7.3.1.5 Static Variable Binding

static variable gets bounded prior to runtime.

advantages:

1. the compiler can use an "absolute addressing mode" to access that variable.
2. compilers can access static variables easier since there's no additional startup
3. static fields retain the value until explicitly changed or the program terminates
4. different threads in a multithreaded application can share the same static variable.

disadvantages:

1. since the lifetime of a static field is prior to runtime all the way till the program terminates,
it will consume memory the entire time.
2. if the compiler utilizies "absolute addressing mode", then the entire address gets encoded and makes the instruction massive.
3. even if different threads can share the same static variable, they cant be used concurrently. code that uses static objects
is not "reentrant" which means its not possible for more than one thread to execute the same code concurrently.

7.3.2 Psuedo-Static Binding and Automatic Variables

automatic variables have their memory and storage allocated at runtime by some block of code/procedure.
"the runtime code automatically allocates and deallocates storage for them".

the reason why it's called "psuedo-static" is because the offset needed to store these variables is calculated already at compile them.

so if there are 5 int variables made that are psuedo-static, the compiler knows that it needs to allocate at least 20 bytes of memory,
and then just offset those bytes of memory below the base pointer. and that 20 bytes doesn't change during runtime.

a local variables name is static because of scope. if int i is inside of a function, that name "i" is statically bound to a given procedure,
thus local variables have a static attribute and thus can not be automatic variables. "keep in mind that local is a static attribute and automatic
is a dynamic one."

the book mentions that setting up, executing, and maintaing automatic variables is extra operations, the compiler only needs a couple of machine instructions,
and a automatic variable only needs to be setup once per procedure, and that setting up and tearing down the activation record doesn't really matter.

advantages of automatic variables:

1. they only consume storage only while the scope they are in is being executed. so if int i is inside of Function A() and Function A() is done,
the int i gets deallocated.
1a. because of this, multiple procedures can share the same pool of memory
2. they tend to use a "base-plus-offset addressing mode", so when you load in a int i, instead of loading in 32 bit address, just load in a 4 byte displacement.
3. local variables are thread safe and can be reentrant. meaning you can call the same function multiple times with no collissions.
3a. this is because each thread has its own stack, where the local variables are maintained. so each thread has its own copies of a local variable.

disadvantages:

1. you have to use machine instructions to load a local variable in
2. whenever you leave the scope you lose the local variable

7.3.3 Dynamic Binding and Dynamic Variables

"A dynamic variable has storage bound to it at runtime". the heap takes care of dynamic variables.

the compiler can not determine the memory address of a dynamic variable at runtime, so you have to use a pointer.

the application controls the lifetime of dynamic variables.

the lifetime of a dynamic variable is not tied to some other object (like how a local variable is tied to scope).

the dynamic variable starts its lifetime, a.k.a when memory is allocated to the variable, once the variable first needs it. you -
can then release the variable once you do not need it.

advantages:

1. if a CPU register already holds the pointer of a dynamic variable, then the compiler can quickly get the data for that pointer with very short instructions.
1a. because of this, the compiler does not need to use any bits for encodng or calculating an offset.

disadvantages:

1. lots of storage (in comparison to local and static). the runtime system will use bytes to keep track of dynamic variables
1a. the compiler keeps track of the dynamic variable's memory address, the size of the object, and its type.
1b. sometimes this "bookeeping" could even be BIGGER than the actual data you are storing (if its just small ints)
2. since dynamic variables are found almost always in memory, the CPU has to access memory which is slower than cached memory.
3. you require 2 operations to access a dynamic variable: first to grab the pointer's value and then fetch the dynamic data.
4. when you declare a dynamic object, the heap/runtime "has to search for a contiguous block of free memory large enough" for the variable.
5. most of the time, deallocating and allocating memory for a dynamic variable on the heap is more expensive than deallocating and allocating local variables
when the program exits the scope.
6. manual deallocation and allocation is hard and human error will occur. 