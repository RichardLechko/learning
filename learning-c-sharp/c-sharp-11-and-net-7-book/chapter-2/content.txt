# Introducing the C# Language

## Understanding language versions and features

The book spends time talking about C# 1 and how it progressed, idc

"C# 11 was released in November 2022" and it added:

- Raw string literals
- Line breaks in interpolated string expressions
- Required properties

"To use a specific version of C#, you must have at least that version of the .NET SDK installed"

so to use C#, at the minimum you need .NET SDK version 7.0 and a Roslyn compiler version 4.4

C# 10 is .NET SDK version 6 and Roslyn 4.0

I ran "dotnet --version" and got 9.0.303 

by default the compiler and CLI will use the latest major version of C#, if you have C# 11 but want to use specific versions like 11.1 or 11.2 -
when they come out, you can use "<LangVersion> a value </LangVersion>" to specify what version. you can enter these values:

- a version number like 7, 11, etc
- latestmajor - the highest major number, so today would be 11
- latest - the highest major and highest minor, so if today's highest was 11.3 that's the latest
- preview - highest available preview version

this is an example:

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net9.0</TargetFramework>
    <LangVersion>preview</LangVersion>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>

## Understanding C# grammar and vocabulary

the book talks about comments and statements. i already know this

then the book talks about blocks, in C# its { ... }

all keywords in C# are lowercase, when you make your own names make them capitalized.

when you read "System.Console.WriteLine" that tells the compiler to look for a method named WriteLine in a type named Console in a namespace named System

when we do "using System;" we are importing a namespace

its standard for every .cs file to have this at the top:

using System;
using System.Linq;
using System.Collections.Generic;

if you do this:

global using System;
global using System.Linq;
global using System.Collections.Generic;

that means you can now use these namespaces in ALL of your .cs files

depending on the project, you will get namespaces imported automatically.

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>

Microsoft.NET.Sdk will automatically import:

- System
- Systme.Collections.Generic
- System.IO
- System.Linq
- System.Net.Http
- System.Threading
- System.Threading.Tasks

if you want to see the imports that were automatically implicitly added:

Go to your Project's Folder > obj > Debug > look for a "GlobalUsings.g.cs" file:

// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

you can add this in your .csproj to control what is implicitly added:

<ItemGroup>
    <Using Remove="System.Threading" />
    <Using Include="System.Numerics" />
</ItemGroup>

now the GlobalUsings.g.cs file changed to:

// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Numerics;
global using global::System.Threading.Tasks;

Threading was removed and now we have Numerics

you can also remove implict imports entirely by chaning:

<ImplicitUsings>enable</ImplicitUsings> --> <ImplicitUsings>disable</ImplicitUsings>

the book then talks about methods, variables, types, etc. I do not care since I already know them

"strictly speaking, C# doesn't define any types. Keywords such as string that look like types are aliases, which represent types provided by the platform on which C# runs."

"In C#, every type can be categorized as a class, struct, enum, interface, or delegate."

string is a class, but int is a struct (what?) so it's best to refer to string and int as 'type'

## Revealing the extent of the C# vocabulary

if you have this code:

using System.Reflection;

Assembly? myApp = Assembly.GetEntryAssembly();

if (myApp == null) return;

foreach (AssemblyName name in myApp.GetReferencedAssemblies())
{
    Assembly a = Assembly.Load(name);

    int methodCount = 0;

    foreach (TypeInfo t in a.DefinedTypes)
    {
        methodCount += t.GetMethods().Count();
    }

    Console.WriteLine(
        "{0:N0} types with {1:N9} methods in {2} assembly.",
        arg0: a.DefinedTypes.Count(),
        arg1: methodCount,
        arg2: name.Name);
}

you get this output:

0 types with 0.000000000 methods in System.Runtime assembly.
110 types with 1,348.000000000 methods in System.Linq assembly.
48 types with 641.000000000 methods in System.Console assembly.

the 0 types in System.Runtime assembly counts only type-forwarders which is a type that is implemented outside of .NET

if you add this code snippet right below the "using System.Reflection;":

System.Data.DataSet ds;
HttpClient client;

then you get this output:

0 types with 0.000000000 methods in System.Runtime assembly.
412 types with 7,190.000000000 methods in System.Data.Common assembly.
423 types with 4,731.000000000 methods in System.Net.Http assembly.
110 types with 1,348.000000000 methods in System.Linq assembly.
48 types with 641.000000000 methods in System.Console assembly.

we declared variables that belong in other assemblies so now those other assemblies are loaded into our app thus we start counting them.

## Variabels

name local and private variables using Camel case -> orderDetail, dateOfBirth
name types, non-private fields, and other members like methods using Pascal case -> String, DateOfBirth, Run

### Declaraing variables and printing them

double heightInMetres = 1.88;
Console.WriteLine($"The variable {nameof(heightInMetres)} has the value {heightInMetres}.");

this outputs:

The variable heightInMetres has the value 1.88.

you can print the name of a variable without hardcoding and get the value

### Literal Values

literal values are just variables with a fixed value

### Storing text

a single letter is stored as a char type.

you assign a value to a char using single quotes:

char letter = 'A';
char digit = '1';
char symbol = '$';
char userChoice = GetSomeKeyStroke();

if you use double quotes you will get an error

multiple letters are stored as string type and are assigned using double quotes or a string return value

string firstName = "Bob";
string lastName = "Smith";
string phoneNumber = "(215) 555-4256";

string horizontalLine = new('-', count: 74);

string address = GetAddressFromDatabase(id: 563);

string grinningEmoji = char.ConvertFromUtf32(0x1F600);

Console.OutputEncoding = System.Text.Encoding.UTF8;
Console.WriteLine(grinningEmoji);

you can also do special characters, like:

string name = "Bob\tSmith";

the \t inserts a tab

if you want to add a literal "\t" into a string and NOT add a tab, you need to prefix with an @ symbol:

string filePath = @"C:\televisions\sony\bravia.txt";

if you have: string filePath = "C:\televisions\sony\bravia.txt";

you will get "Unrecognized escape sequence"

but if you do: string filePath = @"C:\televisions\sony\bravia.txt";

you will get "C:\televisions\sony\bravia.txt"

C# 11 introduced raw string literals:

string xml = """
             <person age="50">
                <first_name>Mark</first_name>
             </person>
             """;
Console.WriteLine(xml);

this will literally print:

<person age="50">
   <first_name>Mark</first_name>
</person>

you can then have raw interpolated string literals:

var person = new { FirstName = "Alice", Age = 56 };

string json = $$"""
              {
                "first_name": "{{person.FirstName}}",
                "age": "{{person.Age}}",
                "calculation": "{{1 + 2}}",
              }
              """;
Console.WriteLine(json);

this will print:

{
  "first_name": "Alice",
  "age": "56",
  "calculation": "3",
}

"the number of dollars tells the compiler how many curly braces are needed for something to become recognized as an interpolated expression."

### Storing Numbers

uint naturalNumber = 23;

int integerNumber = -23;

float realNumber = 2.3F;

double anotherRealNumber = 2.3;

a uint means unsigned integer means it has to be >= 0
an integer just means a number that can be negative, 0, or positive.
float means single-precision floating point and the F makes it a float literal
double means double-precision floating point.

you can add underscores to represent commas for legibility:

int million = 1_000_000;
Console.WriteLine(million);

this will print: 1000000

this is called a digit separator

you can also use binary or hexadecimal notation

there are 3 main numbering systems:

1. Base 10 -> 10 digits from 0 to 9
2. Base 2 -> 2 digits - 0 and 1
3. Base 16 -> 16 digits from 0 to 9 and A to F

int decimalNotation = 2_000_000; // Base 10
int binaryNotation = 0b_0001_1110_1000_0100_1000_0000; // Base 2
int hexadecimalNotation = 0x_001E_8480; // Base 16

Console.WriteLine($"{decimalNotation == binaryNotation}");
Console.WriteLine($"{decimalNotation == hexadecimalNotation}");

this prints:

True
True

heres how 12.75 is represented in binary:

8 + 4 + 1/2 + 1/4 = 12 3/4 = 12.75:

128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 | . | 1/2 | 1/4 | 1/8 | 1/16
0   | 0  | 0  | 0  | 1 | 1 | 0 | 0 | . | 1   | 1   | 0   | 0

12.75 -> 00001100.1100

you can use sizeof to return the number of bytes that a type uses in memory:

Console.WriteLine($"int uses {sizeof(int)} bytes and can store numbers in the range {int.MinValue:N0} to {int.MaxValue:N0}.");
Console.WriteLine($"double uses {sizeof(double)} bytes and can store numbers in the range {double.MinValue:N0} to {double.MaxValue:N0}.");
Console.WriteLine($"decimal uses {sizeof(decimal)} bytes and can store numbers in the range {decimal.MinValue:N0} to {decimal.MaxValue:N0}.");

you will get this printed:

int uses 4 bytes and can store numbers in the range -2,147,483,648 to 2,147,483,647.
double uses 8 bytes and can store numbers in the range -179,769,313,486,231,570,814,527,423,731,704,356,798,070,567,525,844,996,598,917,476,803,157,260,780,028,538,760,589,558,632,766,878,171,540,458,953,514,382,464,234,321,326,889,464,182,768,467,546,703,537,516,986,049,910,576,551,282,076,245,490,090,389,328,944,075,868,508,455,133,942,304,583,236,903,222,948,165,808,559,332,123,348,274,797,826,204,144,723,168,738,177,180,919,299,881,250,404,026,184,124,858,368 to 179,769,313,486,231,570,814,527,423,731,704,356,798,070,567,525,844,996,598,917,476,803,157,260,780,028,538,760,589,558,632,766,878,171,540,458,953,514,382,464,234,321,326,889,464,182,768,467,546,703,537,516,986,049,910,576,551,282,076,245,490,090,389,328,944,075,868,508,455,133,942,304,583,236,903,222,948,165,808,559,332,123,348,274,797,826,204,144,723,168,738,177,180,919,299,881,250,404,026,184,124,858,368.
decimal uses 16 bytes and can store numbers in the range -79,228,162,514,264,337,593,543,950,335 to 79,228,162,514,264,337,593,543,950,335.

some numbers can not be represented in binary:

Console.WriteLine("Using doubles:");
double a = 0.1;
double b = 0.2;
if (a + b == 0.3)
{
    Console.WriteLine($"{a} + {b} equals {0.3}");
}
else
{
    Console.WriteLine($"{a} + {b} does NOT equal {0.3}");
}

you will get:

Using doubles:
0.1 + 0.2 does NOT equal 0.3

0.1 literally can not be represented as a floating-point values.

use doubles when accuracy is not the most important

if you want accuracy use decimal:

Console.WriteLine("Using decimals:");
decimal a = 0.1M;
decimal b = 0.2M;
if (a + b == 0.3M)
{
    Console.WriteLine($"{a} + {b} equals {0.3}");
}
else
{
    Console.WriteLine($"{a} + {b} does NOT equal {0.3}");
}

this will print:

Using decimals:
0.1 + 0.2 equals 0.3

the reason why decimal is accurate is because "it stores the number as a large integer and shifts the decimal point."

so 0.1 becomes 1 but the compiler knows to shift the decimal point one place to the left.
12.75 becomes 1275 and the compiler moves the decimal point 2 places to the left.

int -> whole numbers
double -> real numbers that will not be compared for equality to other values
decimal -> money, CAD drawings, general engineering, anywhere where accuracy is important

float and double types have special values:

NaN -> Not A Number
Epsilon -> smallest positive number
PositiveInfinity -> Positive Infinity
NegativeInfinity -> Negative Infinity
IsInfinity -> Yes/No if something is infinity
IsNan -> Yes/No if something is not a number

### storing booleans

booleans can either be true or false

### storing any type of object

the type "object" can hold any type of data but its hard to read and it has poor performance.

object height = 1.88;
object name = "Amir";
Console.WriteLine($"{name} is {height} metres tall.");

//int length1 = name.Length;
int length2 = ((string)name).Length;
Console.WriteLine($"{name} has {length2} characters.");

you have to cast the name into a string and then call the Length method.

### storing dynamic types

there is another type called "dynamic" that can store any type of data but its performance might be worse than an object

dynamic something = "Ahmed";
Console.WriteLine($"Length is {something.Length}");

this prints: "Length is 5"

but then if you do:

dynamic something = "Ahmed";
something = 12;
Console.WriteLine($"Length is {something.Length}");

you will get an unhandled exception because the type "int" does not have a Length method

then if you do this:

dynamic something = "Ahmed";

something = 12;
something = new[] {3, 5, 7};
Console.WriteLine($"Length is {something.Length}");

you will get "Length is 3"

problem with dynamic is IntelliSense can not help you since the compiler can not check the type of a variable at build time.

### declaring local variables

int population = 67_000_000;
double weight = 1.88;
decimal price = 4.99M;
string fruit = "Apples";
char letter = 'Z';
bool happy = true;

if you type a number without a decimal point it's then inferred as an int. to specify what number you want to use, you need to add a suffix:

L -> long
UL -> ulong
M -> decimal
D -> double
F -> float

a number with a decimal point is inferred as a double unless you add a M suffix to specify it as a decimal.

var population = 67_000_000;
var weight = 1.88;
var price = 4.99M;
var fruit = "Apples";
var letter = 'Z';
var happy = true;

// good use of var because it avoids the repeated type
var xml1 = new XmlDocument();
XmlDocument xml2 = new XmlDocument();

// bad use of var because we can not tell the type
var file1 = File.CreateText("something1.txt");
StreamWriter file2 = File.CreateText("something2.txt");

if you hover over the var for the basic types above, it'll say exactly what it is.

but if you hover over the file1 var, you can not determine the type. which is bad.

### using target-typed new to instantiate objects

target-typed new is where you specify the type before declaring an object which determines the objects type:

XmlDocument xml3 = new();

so if you have this Class:

class Person
{
  public DateTime BirthDate;
}

you can then write:

Person kim = new();
kim.BirthDate = new(1967, 12, 26);

instead of writing:

Person kim = new();
kim.BirthDate = new DateTime(1967, 12, 26);

you can also expand this to arrays and collections:

List<Person> people = new()
{
  new() { FirstName = "Alice" },
  new() { FirstName = "Bob" },
  new() { FirstName = "Charlie" },
}

### getting and setting the default values for types

you can use the default operator to get the default value of a primitve data type

you can not do this with "string" because string type is a reference type. string holds the memory address of a value not the actual value

Console.WriteLine($"default(int) = {default(int)}");
Console.WriteLine($"default(bool) = {default(bool)}");
Console.WriteLine($"default(DateTime) = {default(DateTime)}");
Console.WriteLine($"default(string) = {default(string)}");

this will print:

default(int) = 0
default(bool) = False
default(DateTime) = 01/01/0001 00:00:00
default(string) = 

you can also reset the value of a variable after its set:

int number = 13;

Console.WriteLine($"number has been set to: {number}");

number = default;
Console.WriteLine($"number has been reset to its default: {number}");
Console.WriteLine($"default(int) = {default(int)}");
Console.WriteLine($"default(bool) = {default(bool)}");
Console.WriteLine($"default(DateTime) = {default(DateTime)}");
Console.WriteLine($"default(string) = {default(string)}");

this will print:

number has been set to: 13
number has been reset to its default: 0
default(int) = 0
default(bool) = False
default(DateTime) = 01/01/0001 00:00:00
default(string) = 

# Exploring more about console apps

console apps are text based and run at the cli

### displaying output to the user

console apps can write and read data.

int numberOfApples = 12;
decimal pricePerApple = 0.35M;

Console.WriteLine(
    format: "{0} apples cost {1:C}",
    arg0: numberOfApples,
    arg1: pricePerApple * numberOfApples);

you can pass arguments into WriteLine. but you can only pass up to 3, if more than 3 you can not name them:

Console.WriteLine(
    format: "{0} {1} lived in {2}.",
    arg0: "Roger", arg1: "Cevung",
    arg2: "Stockholm, Stockholm");

Console.WriteLine(
    format: "{0} {1} lived in {2}, {3} and worked in the {4} team at {5}.",
    "Roger", "Cevung", "Stockholm", "Sweden", "Education", "Optimizely");
  
but now there are interpolated strings

Console.WriteLine($"{numberOfApples} apples cost {pricePerApple * numberOfApples:C}");

this will print: 12 apples cost ¤4.20

you can also concatenate strings using interpolated strings:

const string firstname = "Omar";
const string lastname = "Rudberg";
const string fullname = $"{firstname} {lastname}";
Console.WriteLine(fullname);

this prints: Omar Rudberg

## formatting strings

whenever you are formatting a string there are multiple suffixes:

N0 Format -> a number with thousands separators and no decimal places
C -> currnecy

if you have this code:

string applesText = "Apples";
int applesCount = 1234;
string bananasText = "Bananas";
int bananasCount = 56789;

Console.WriteLine(
    format: "{0,-10} {1,6}",
    arg0: "Name",
    arg1: "Count");
Console.WriteLine(
    format: "{0,-10} {1,6:N0}",
    arg0: applesText,
    arg1: applesCount);
Console.WriteLine(
    format: "{0,-10} {1,6:N0}",
    arg0: bananasText,
    arg1: bananasCount);

you will get this output:

Name        Count
Apples      1,234
Bananas    56,789

## Getting text input from the user

you can get text input using ReadLine:

Console.Write("Type your first name and press ENTER: ");
string firstName = Console.ReadLine();

Console.Write("Type your age and press ENTER: ");
string age = Console.ReadLine();

Console.WriteLine($"Hello {firstName}, you look good for {age}.");

there are null warnings. if you are expecting a null answer for either firstName or age, just add a ? after the type:

string? firstName = Console.ReadLine();
string? age = Console.ReadLine();

if you know there should NEVER be null returned, you can add a ! before the semi-colon:

string firstName = Console.ReadLine()!;
string age = Console.ReadLine()!;

now you have to make sure there is not a null ever

you can simplify your code:

using static System.Console;

Write("Type your first name and press ENTER: ");
string firstName = Console.ReadLine()!;

Write("Type your age and press ENTER: ");
string age = Console.ReadLine()!;

WriteLine($"Hello {firstName}, you look good for {age}.");

so now you do not need to constantly add "Console."

or you can add that static import to the .csproj:

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <Using Include="System.Console" Static="true" />
  </ItemGroup>

</Project>

so now for every .cs file, the System.Console is statically imported.

you can also get user input besides just the user pressing Enter:

Write("Press any key combination: ");
ConsoleKeyInfo key = ReadKey();
WriteLine();
WriteLine("Key: {0}, Char: {1}, Modifiers: {2}",
    arg0: key.Key,
    arg1: key.KeyChar,
    arg2: key.Modifiers);

❯ dotnet run
Press any key combination: k
Key: K, Char: k, Modifiers: None
❯ dotnet run
Press any key combination: K
Key: K, Char: K, Modifiers: Shift
❯ dotnet run
Press any key combination: 
Key: F12, Char: , Modifiers: None

you can see when you do Shift + K, the modifiers catches the shift key stroke.

### passing arguments into a console app

command line arguments are sparated by spaces.

just as a test:

WriteLine($"There are {args.Length} arguments.");

then if you run "dotnet run" this will print "There are 0 arguments." which makes sense

if you run "dotnet run firstarg second-arg third:arg "fourth arg"":

There are 4 arguments.

and then if you want to loop through each argument:

WriteLine($"There are {args.Length} arguments.");

foreach (string arg in args)
{
    WriteLine(arg);
}

when you run ""dotnet run firstarg second-arg third:arg "fourth arg"":

There are 4 arguments.
firstarg
second-arg
third:arg
fourth arg

### setting options with arguments

if (args.Length < 3)
{
    WriteLine("You must specify two colors and cursor size, e.g.");
    WriteLine("dotnet run red yellow 50");
    return;
}

ForegroundColor = (ConsoleColor)Enum.Parse(
    enumType: typeof(ConsoleColor),
    value: args[0],
    ignoreCase: true);

BackgroundColor = (ConsoleColor)Enum.Parse(
    enumType: typeof(ConsoleColor),
    value: args[1],
    ignoreCase: true);

CursorSize = int.Parse(args[2]);

then when you run "dotnet run red yellow 50" it will set the foreground to red, background to yellow, and cursor size to 50%

the CursorSize only works on Windows, so we need to do a try & catch:

ForegroundColor = (ConsoleColor)Enum.Parse(
    enumType: typeof(ConsoleColor),
    value: args[0],
    ignoreCase: true);

BackgroundColor = (ConsoleColor)Enum.Parse(
    enumType: typeof(ConsoleColor),
    value: args[1],
    ignoreCase: true);
try
{
    CursorSize = int.Parse(args[2]);
}
catch (PlatformNotSupportedException)
{
    WriteLine("The current platform does not support changing the size of the cursor.");
}

or you can also do an if condition and do different things depending on the machine:

if (OperatingSystem.IsWindows())
{
    // execute code that only works on Windows
}
else if (OperatingSystem.IsWindowsVersionAtLeast(major: 10))
{
    // execute code that only works on Windows 10 or later
}
else if (OperatingSystem.IsIOSVersionAtLeast(major: 14, minor: 5))
{
    // execute code that only works on iOS 14.5 or later
}
else if (OperatingSystem.IsBrowser())
{
    // execute code that only works in the browser with Blazor
}

or you can use manifest constants:

#if NET7_0_ANDROID
#elif NET7_0_IOS
#else
#endif

## Understanding async and await

this is a simple piece of code showing an HTTP Client using await:

HttpClient client = new();

HttpResponseMessage response =
    await client.GetAsync("http://www.apple.com/");

WriteLine("Apple's home page has {0:N0} bytes.",
    response.Content.Headers.ContentLength);

this returns "Apple's home page has 194,638 bytes."

